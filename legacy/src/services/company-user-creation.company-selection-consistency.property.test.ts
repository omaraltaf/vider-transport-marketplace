/**
 * Property-Based Test: Company Selection Consistency
 * **Feature: company-user-creation, Property 5: Company Selection Consistency**
 * **Validates: Requirements 3.1, 3.2**
 * 
 * Tests that company selection operations return consistent data with database records
 */

import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import { PrismaClient } from '@prisma/client';
import request from 'supertest';
import { createApp } from '../app';
import fc from 'fast-check';

const prisma = new PrismaClient();

// Test data setup
let testCompanies: any[] = [];
let adminToken: string;
const app = createApp();

beforeAll(async () => {
  // Create multiple test companies
  const companyPromises = Array.from({ length: 5 }, (_, i) => 
    prisma.company.create({
      data: {
        name: `Test Company ${i + 1} for Selection`,
        organizationNumber: `TEST${Date.now()}${i}`,
        businessAddress: 'Test Business Address',
        city: i % 2 === 0 ? 'Oslo' : 'Bergen',
        postalCode: '0001',
        fylke: i % 2 === 0 ? 'Oslo' : 'Vestland',
        kommune: i % 2 === 0 ? 'Oslo' : 'Bergen',
        vatRegistered: true,
        description: `Test company ${i + 1} for selection`,
        verified: true,
        verifiedAt: new Date(),
        aggregatedRating: 4.0,
        totalRatings: 1,
        status: 'ACTIVE'
      }
    })
  );

  testCompanies = await Promise.all(companyPromises);

  // Create admin user and get token
  const adminUser = await prisma.user.create({
    data: {
      email: `admin-selection-${Date.now()}@example.com`,
      firstName: 'Admin',
      lastName: 'User',
      phone: '+47 12345678',
      role: 'PLATFORM_ADMIN',
      passwordHash: 'dummy-hash',
      emailVerified: true,
      company: {
        connect: { id: testCompanies[0].id }
      }
    }
  });

  // Mock admin token (in real app, this would be generated by auth system)
  adminToken = 'mock-admin-token';
});

afterAll(async () => {
  // Clean up test data - delete users first to avoid foreign key constraints
  await prisma.user.deleteMany({
    where: {
      OR: [
        { email: { contains: 'admin-selection' } },
        { companyId: { in: testCompanies.map(c => c.id) } }
      ]
    }
  });

  await prisma.company.deleteMany({
    where: {
      name: { contains: 'Test Company' }
    }
  });

  await prisma.$disconnect();
});

describe('Property 5: Company Selection Consistency', () => {
  it.skip('should return consistent company data across multiple requests', async () => {
    await fc.assert(
      fc.asyncProperty(
        fc.integer({ min: 1, max: 3 }),
        async (requestCount) => {
          const responses = [];
          
          // Make multiple requests for the same company data
          for (let i = 0; i < requestCount; i++) {
            const response = await request(app)
              .get('/api/platform-admin/users/companies/options?limit=50')
              .set('Authorization', `Bearer ${adminToken}`);
            
            responses.push(response);
          }

          // All responses should be successful
          responses.forEach(response => {
            expect(response.status).toBe(200);
            expect(response.body.success).toBe(true);
          });

          // All responses should return the same data
          const firstResponseData = responses[0].body.data;
          responses.slice(1).forEach(response => {
            expect(response.body.data.companies).toEqual(firstResponseData.companies);
            expect(response.body.data.total).toBe(firstResponseData.total);
          });
        }
      ),
      { numRuns: 10 }
    );
  });

  it.skip('should return companies that exist in the database', async () => {
    await fc.assert(
      fc.asyncProperty(
        fc.option(fc.string({ minLength: 1, maxLength: 10 }), { nil: undefined }),
        async (searchTerm) => {
          const queryParams = new URLSearchParams();
          if (searchTerm) {
            queryParams.append('search', searchTerm);
          }
          queryParams.append('limit', '50');

          const response = await request(app)
            .get(`/api/platform-admin/users/companies/options?${queryParams}`)
            .set('Authorization', `Bearer ${adminToken}`);

          expect(response.status).toBe(200);
          expect(response.body.success).toBe(true);

          const returnedCompanies = response.body.data.companies;

          // Verify each returned company exists in database
          for (const company of returnedCompanies) {
            const dbCompany = await prisma.company.findUnique({
              where: { id: company.id },
              select: {
                id: true,
                name: true,
                organizationNumber: true,
                city: true,
                fylke: true,
                status: true,
                verified: true
              }
            });

            expect(dbCompany).toBeTruthy();
            expect(dbCompany?.id).toBe(company.id);
            expect(dbCompany?.name).toBe(company.name);
            expect(dbCompany?.organizationNumber).toBe(company.organizationNumber);
            expect(dbCompany?.city).toBe(company.city);
            expect(dbCompany?.fylke).toBe(company.fylke);
            expect(dbCompany?.status).toBe('ACTIVE');
            expect(dbCompany?.verified).toBe(true);
          }
        }
      ),
      { numRuns: 10 }
    );
  });

  it.skip('should filter companies correctly based on search terms', async () => {
    await fc.assert(
      fc.asyncProperty(
        fc.oneof(
          fc.constant('Oslo'),
          fc.constant('Bergen'),
          fc.constant('Test Company'),
          fc.constant('TEST')
        ),
        async (searchTerm) => {
          const response = await request(app)
            .get(`/api/platform-admin/users/companies/options?search=${encodeURIComponent(searchTerm)}&limit=50`)
            .set('Authorization', `Bearer ${adminToken}`);

          expect(response.status).toBe(200);
          expect(response.body.success).toBe(true);

          const returnedCompanies = response.body.data.companies;

          // Verify all returned companies match the search criteria
          returnedCompanies.forEach((company: any) => {
            const matchesSearch = 
              company.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
              company.organizationNumber.toLowerCase().includes(searchTerm.toLowerCase()) ||
              company.city.toLowerCase().includes(searchTerm.toLowerCase());
            
            expect(matchesSearch).toBe(true);
          });
        }
      ),
      { numRuns: 10 }
    );
  });

  it.skip('should return only active and verified companies', async () => {
    await fc.assert(
      fc.asyncProperty(
        fc.integer({ min: 10, max: 100 }),
        async (limit) => {
          const response = await request(app)
            .get(`/api/platform-admin/users/companies/options?limit=${limit}`)
            .set('Authorization', `Bearer ${adminToken}`);

          expect(response.status).toBe(200);
          expect(response.body.success).toBe(true);

          const returnedCompanies = response.body.data.companies;

          // Verify all returned companies are active and verified
          returnedCompanies.forEach((company: any) => {
            expect(company.status).toBe('ACTIVE');
            expect(company.verified).toBe(true);
          });

          // Verify against database
          for (const company of returnedCompanies) {
            const dbCompany = await prisma.company.findUnique({
              where: { id: company.id },
              select: { status: true, verified: true }
            });

            expect(dbCompany?.status).toBe('ACTIVE');
            expect(dbCompany?.verified).toBe(true);
          }
        }
      ),
      { numRuns: 10 }
    );
  });

  it.skip('should respect limit parameter', async () => {
    await fc.assert(
      fc.asyncProperty(
        fc.integer({ min: 1, max: 10 }),
        async (limit) => {
          const response = await request(app)
            .get(`/api/platform-admin/users/companies/options?limit=${limit}`)
            .set('Authorization', `Bearer ${adminToken}`);

          expect(response.status).toBe(200);
          expect(response.body.success).toBe(true);

          const returnedCompanies = response.body.data.companies;
          expect(returnedCompanies.length).toBeLessThanOrEqual(limit);
        }
      ),
      { numRuns: 10 }
    );
  });

  it.skip('should return consistent total count', async () => {
    await fc.assert(
      fc.asyncProperty(
        fc.option(fc.string({ minLength: 1, maxLength: 5 }), { nil: undefined }),
        async (searchTerm) => {
          const queryParams = new URLSearchParams();
          if (searchTerm) {
            queryParams.append('search', searchTerm);
          }
          queryParams.append('limit', '50');

          const response = await request(app)
            .get(`/api/platform-admin/users/companies/options?${queryParams}`)
            .set('Authorization', `Bearer ${adminToken}`);

          expect(response.status).toBe(200);
          expect(response.body.success).toBe(true);

          const { companies, total } = response.body.data;

          // Total should be >= returned companies count
          expect(total).toBeGreaterThanOrEqual(companies.length);

          // Verify total matches database count with same filters
          const whereClause: any = {
            status: 'ACTIVE',
            verified: true
          };

          if (searchTerm) {
            whereClause.OR = [
              { name: { contains: searchTerm, mode: 'insensitive' } },
              { organizationNumber: { contains: searchTerm } },
              { city: { contains: searchTerm, mode: 'insensitive' } }
            ];
          }

          const dbTotal = await prisma.company.count({ where: whereClause });
          expect(total).toBe(dbTotal);
        }
      ),
      { numRuns: 10 }
    );
  });
});